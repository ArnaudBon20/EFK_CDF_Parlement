// Variables used by Scriptable.
// These must be at the very top of the file. Do not edit.
// icon-color: red; icon-glyph: file-alt;

/**
 * Widget Curia Vista - Interpellations mentionnant CDF/EFK
 * Langue: automatique selon la langue iOS (Device.language())
 *
 * Affichage:
 *  - Titre centré en haut
 *  - Ligne "nouveautés": numéros (sur 1 ligne) ou ❌
 *  - 3 dernières interpellations: numéro + titre + "Nom (Parti)" si possible
 * Tap -> ouvre la recherche Curia Vista
 */

const UPDATE_HOUR = 0;
const UPDATE_MINUTE = 30;

const CFG = {
  fr: {
    title: "Le CDF au Parlement",
    url: 'https://www.parlament.ch/fr/ratsbetrieb/suche-curia-vista#k=%22Contr%C3%B4le%20f%C3%A9d%C3%A9ral%20des%20finances%22',
    acceptLang: "fr-CH,fr;q=0.9",
    authorKeys: ["auteur", "auteure", "autrice", "auteur/trice", "auteur·e", "déposant", "déposante"],
  },
  de: {
    title: "Die EFK im Parlament",
    url: 'https://www.parlament.ch/de/ratsbetrieb/suche-curia-vista#k=%22Eidgen%C3%B6ssische%20Finanzkontrolle%22#l=1033',
    acceptLang: "de-CH,de;q=0.9",
    authorKeys: ["urheber", "urheber/in", "einreicher", "einreicherin"],
  },
};

// ---------- Utils ----------
function pickLangAuto() {
  const ui = (Device.language() || "").toLowerCase(); // langue UI iOS
  if (ui.startsWith("de")) return "de";
  return "fr";
}

function nowISO() {
  return new Date().toISOString();
}

function decodeHtmlEntities(str) {
  if (!str) return "";
  return String(str)
    .replace(/&nbsp;/gi, " ")
    .replace(/&amp;/gi, "&")
    .replace(/&quot;/gi, '"')
    .replace(/&#039;/gi, "'")
    .replace(/&lt;/gi, "<")
    .replace(/&gt;/gi, ">")
    .replace(/&#(\d+);/g, (_, code) => {
      try {
        return String.fromCharCode(parseInt(code, 10));
      } catch {
        return _;
      }
    })
    .replace(/[’‘‛]/g, "'")
    .trim();
}

function stripTags(html) {
  return decodeHtmlEntities(String(html || "").replace(/<[^>]*>/g, " "));
}

function normalizeSpace(s) {
  return String(s || "")
    .replace(/\s+/g, " ")
    .replace(/\s+\|\s+/g, " | ")
    .trim();
}

function clamp(s, max) {
  const x = String(s || "");
  if (x.length <= max) return x;
  return x.slice(0, Math.max(0, max - 1)).trimEnd() + "…";
}

// Extrait "Nom (Parti)" à partir d'une chaîne auteur (souvent: "Prénom Nom (SP, ZH)" ou similaire)
// - garde uniquement le nom de famille (dernier token) + parti si détectable
function formatAuthorSurnameParty(authorRaw) {
  const raw = normalizeSpace(authorRaw);
  if (!raw) return "";

  // si plusieurs auteurs: garde le premier
  const first = raw.split(" / ")[0].split(";")[0].split(" | ")[0].trim();

  // parti: contenu dans parenthèses -> on prend le 1er élément avant virgule
  // ex: "(SP, ZH)" -> "SP"
  // ex: "(PS)" -> "PS"
  let party = "";
  const paren = first.match(/\(([^)]+)\)/);
  if (paren && paren[1]) {
    const inside = normalizeSpace(paren[1]);
    const firstPart = inside.split(",")[0].trim();
    // garde une abréviation plausible (lettres + éventuellement tiret)
    if (/^[A-ZÄÖÜ]{1,6}(-[A-ZÄÖÜ]{1,6})?$/.test(firstPart)) {
      party = firstPart;
    } else {
      // parfois "SP/PS" etc.
      const m = firstPart.match(/[A-ZÄÖÜ]{1,6}(?:-[A-ZÄÖÜ]{1,6})?/);
      if (m) party = m[0];
    }
  }

  // retire tout ce qui est entre parenthèses pour isoler le nom
  const noParen = normalizeSpace(first.replace(/\([^)]*\)/g, "").trim());
  // retire éventuels préfixes type "Auteur:" déjà présents
  const cleaned = noParen.replace(/^(auteur|auteure|autrice|déposant|déposante|urheber|einreicher)\s*:?/i, "").trim();

  // nom de famille = dernier token (en gardant traits d'union / apostrophes)
  const tokens = cleaned.split(" ").filter(Boolean);
  const surname = tokens.length ? tokens[tokens.length - 1] : cleaned;

  if (!surname) return "";
  return party ? `${surname} (${party})` : surname;
}

// Tente d’extraire l’auteur dans un snippet texte, à partir de mots-clés (FR/DE)
function extractAuthorFromText(text, authorKeys) {
  const original = normalizeSpace(text);
  const lower = (" " + original.toLowerCase() + " ");

  for (const key of authorKeys) {
    const k = " " + key.toLowerCase() + " ";
    const idx = lower.indexOf(k);
    if (idx !== -1) {
      // prend une fenêtre après le keyword
      const start = Math.max(0, idx);
      const tail = original.slice(start, start + 260);

      // privilégie ce qui suit ":" si présent
      const parts = tail.split(":");
      const candidate = normalizeSpace((parts.length > 1 ? parts.slice(1).join(":") : tail)
        .replace(new RegExp(key, "i"), "")
        .trim());

      // coupe sur séparateurs fréquents
      const cut = candidate.split(" | ")[0].split(" - ")[0].split(" / ")[0].trim();
      if (cut && cut.length > 2) return cut;
    }
  }
  return "";
}

// Tente d’extraire un titre dans un snippet HTML
function extractTitleFromSnippet(snippetHtml, num) {
  const afterIdx = snippetHtml.indexOf(num);
  const slice = afterIdx >= 0 ? snippetHtml.slice(afterIdx, afterIdx + 1400) : snippetHtml;

  const aRe = /<a\b[^>]*>([\s\S]*?)<\/a>/gi;
  let m;
  while ((m = aRe.exec(slice)) !== null) {
    const txt = normalizeSpace(stripTags(m[1]));
    if (!txt) continue;
    if (txt === num) continue;
    if (txt.length < 6) continue;
    if (/^(details|détails|pdf|weiter|mehr)$/i.test(txt)) continue;
    return txt;
  }

  const text = normalizeSpace(stripTags(slice));
  const cleaned = normalizeSpace(text.replace(num, "").trim());
  return cleaned.split(" | ")[0].split(" - ")[0].trim();
}

// ---------- Fetcher / Cache ----------
class CuriaVistaFetcher {
  constructor(cfg, key) {
    this.cfg = cfg;
    this.key = key;

    this.fm = FileManager.local();
    this.dir = this.fm.joinPath(this.fm.documentsDirectory(), "cdf-efk-curiavista");
    if (!this.fm.fileExists(this.dir)) this.fm.createDirectory(this.dir, true);

    this.cacheItemsPath = this.fm.joinPath(this.dir, `cacheItems_${key}.json`); // [{num,title,author}]
    this.lastUpdatePath = this.fm.joinPath(this.dir, `lastUpdate_${key}.txt`);
    this.seenNumsPath = this.fm.joinPath(this.dir, `seenNums_${key}.json`); // [num]
    this.lastNewNumsPath = this.fm.joinPath(this.dir, `lastNewNums_${key}.json`); // [num]
  }

  loadJSON(path, fallback) {
    if (!this.fm.fileExists(path)) return fallback;
    try {
      return JSON.parse(this.fm.readString(path));
    } catch {
      return fallback;
    }
  }

  saveJSON(path, obj) {
    try {
      this.fm.writeString(path, JSON.stringify(obj));
      return true;
    } catch {
      return false;
    }
  }

  getLastUpdateDate() {
    if (!this.fm.fileExists(this.lastUpdatePath)) return new Date(0);
    try {
      return new Date(this.fm.readString(this.lastUpdatePath));
    } catch {
      return new Date(0);
    }
  }

  shouldUpdate() {
    const now = new Date();
    const lastUpdate = this.getLastUpdateDate();
    const todayUpdate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), UPDATE_HOUR, UPDATE_MINUTE);

    if (!this.fm.fileExists(this.cacheItemsPath)) return true;
    if (now >= todayUpdate && lastUpdate < todayUpdate) return true;

    return false;
  }

  async fetchHTML() {
    const req = new Request(this.cfg.url);
    req.headers = {
      "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15",
      "Accept-Language": this.cfg.acceptLang,
    };
    return await req.loadString();
  }

  parseInterpellations(html) {
    const items = [];
    if (!html) return items;

    const numRe = /\b(\d{2}\.\d{4})\b/g;
    const matches = [...html.matchAll(numRe)];
    if (matches.length === 0) return items;

    for (const m of matches) {
      const num = m[1];
      const idx = m.index ?? -1;
      if (idx < 0) continue;

      const start = Math.max(0, idx - 900);
      const end = Math.min(html.length, idx + 2000);
      const snippetHtml = html.slice(start, end);
      const snippetTextLower = normalizeSpace(stripTags(snippetHtml)).toLowerCase();

      if (!snippetTextLower.includes("interpellation")) continue;
      if (items.some((it) => it.num === num)) continue;

      const title = extractTitleFromSnippet(snippetHtml, num);
      const authorRaw = extractAuthorFromText(stripTags(snippetHtml), this.cfg.authorKeys);
      const author = formatAuthorSurnameParty(authorRaw);

      items.push({
        num,
        title: normalizeSpace(title),
        author: normalizeSpace(author),
      });
    }

    return items;
  }

  loadItemsCache() {
    return this.loadJSON(this.cacheItemsPath, []);
  }

  loadSeenNums() {
    return this.loadJSON(this.seenNumsPath, []);
  }

  saveSeenNums(arr) {
    this.saveJSON(this.seenNumsPath, arr);
  }

  loadLastNewNums() {
    return this.loadJSON(this.lastNewNumsPath, []);
  }

  saveLastNewNums(arr) {
    this.saveJSON(this.lastNewNumsPath, arr);
  }

  async getItemsAndMaybeUpdate() {
    const cached = this.loadItemsCache();

    if (!this.shouldUpdate()) {
      return { items: cached, didUpdate: false };
    }

    try {
      const html = await this.fetchHTML();
      const items = this.parseInterpellations(html);

      if (items.length > 0) {
        this.saveJSON(this.cacheItemsPath, items);
        this.fm.writeString(this.lastUpdatePath, nowISO());
        return { items, didUpdate: true };
      }

      return { items: cached, didUpdate: false };
    } catch (e) {
      console.error("fetch error:", e);
      return { items: cached, didUpdate: false };
    }
  }
}

// ---------- UI ----------
function addCenteredTitle(w, text) {
  const t = w.addText(text);
  t.font = Font.boldSystemFont(14);
  t.centerAlignText();
}

function addLine(w, text, { bold = false, centered = false, size = 12, color = null, lineLimit = 1 } = {}) {
  const t = w.addText(text);
  t.font = bold ? Font.boldSystemFont(size) : Font.systemFont(size);
  t.lineLimit = lineLimit;
  if (centered) t.centerAlignText();
  if (color) t.textColor = color;
  return t;
}

// ---------- Main ----------
const lang = pickLangAuto();
const cfg = CFG[lang];

const fetcher = new CuriaVistaFetcher(cfg, lang);
const { items: allItems, didUpdate } = await fetcher.getItemsAndMaybeUpdate();

const numsNow = (allItems || []).map((x) => x.num);
let newNumsToShow = fetcher.loadLastNewNums();

if (didUpdate) {
  const seenNums = fetcher.loadSeenNums();
  const newNums = numsNow.filter((n) => !seenNums.includes(n));

  fetcher.saveLastNewNums(newNums);
  fetcher.saveSeenNums(numsNow);

  newNumsToShow = newNums;
}

const last3 = (allItems || []).slice(0, 3);

const w = new ListWidget();
w.url = cfg.url;
w.setPadding(6, 12, 12, 12);

// Titre centré tout en haut
addCenteredTitle(w, cfg.title);
w.addSpacer(6);

// Ligne nouveautés: numéros sur une ligne sinon ❌
if (newNumsToShow && newNumsToShow.length > 0) {
  addLine(w, newNumsToShow.join(" / "), { bold: true, centered: true, size: 12, lineLimit: 1 });
} else {
  addLine(w, "❌", { bold: true, centered: true, size: 12 });
}

w.addSpacer(8);

// 3 dernières: numéro + titre + auteur formaté "Nom (Parti)"
if (last3.length === 0) {
  addLine(w, "—", { size: 12 });
} else {
  for (const it of last3) {
    const num = it.num || "";
    const title = it.title ? clamp(it.title, 60) : "";
    const author = it.author ? clamp(it.author, 40) : "";

    const header = title ? `${num} — ${title}` : num;
    addLine(w, header, { bold: true, size: 11, lineLimit: 1 });

    if (author) {
      addLine(w, author, { size: 10, color: Color.gray(), lineLimit: 1 });
    }

    w.addSpacer(4);
  }
}

Script.setWidget(w);
Script.complete();
