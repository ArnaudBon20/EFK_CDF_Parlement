// Variables used by Scriptable.
// These must be at the very top of the file. Do not edit.
// icon-color: red; icon-glyph: gavel;

/**
 * Widget Scriptable — "Le CDF au Parlement" / "Die EFK im Parlament"
 * - Langue auto selon iOS
 * - Source: Webservices Parlement (ws-old.parlament.ch)
 * - Affiche:
 *   1) Sur une ligne: numéros des nouvelles interpellations depuis hier (sinon ❌)
 *   2) Les 3 dernières interpellations (numéro + titre + auteur + parti si dispo)
 * - En cliquant: ouvre la recherche Curia Vista (FR/DE)
 */

const UPDATE_HOUR = 0;
const UPDATE_MINUTE = 30;

const BASE = "https://ws-old.parlament.ch";
const TYPE_IDS = new Set([8, 9]); // 8=Interpellation, 9=Interpellation urgente

const SEARCH_URL_FR =
  "https://www.parlament.ch/fr/ratsbetrieb/suche-curia-vista#k=%22Contr%C3%B4le%20f%C3%A9d%C3%A9ral%20des%20finances%22";
const SEARCH_URL_DE =
  "https://www.parlament.ch/de/ratsbetrieb/suche-curia-vista#k=%22Eidgen%C3%B6ssische%20Finanzkontrolle%22#l=1033";

// Couleurs
const RED = new Color("#E30613");
const TEXT_PRIMARY = new Color("#111111");
const TEXT_SECONDARY = new Color("#666666");
const BG = new Color("#FFFFFF");

// ------------------ Langue auto iOS ------------------
function detectLang() {
  const forced = (args.widgetParameter ? String(args.widgetParameter) : "").trim().toLowerCase();
  if (forced === "fr" || forced === "de") return forced;

  let preferred = [];
  try {
    preferred = (Device.preferredLanguages ? Device.preferredLanguages() : []) || [];
  } catch (e) {}

  const joined = preferred.map(String).join(" ").toLowerCase();
  if (joined.includes("fr")) return "fr";
  if (joined.includes("de")) return "de";

  // fallback
  return "fr";
}

const LANG = detectLang();
const TITLE = LANG === "fr" ? "Le CDF au Parlement" : "Die EFK im Parlament";
const KEYWORD = LANG === "fr" ? "Contrôle fédéral des finances" : "Eidgenössische Finanzkontrolle";
const WIDGET_URL = LANG === "fr" ? SEARCH_URL_FR : SEARCH_URL_DE;

// ------------------ Utils ------------------
async function fetchJSON(url) {
  const r = new Request(url);
  r.headers = { "Accept": "application/json" };
  r.timeoutInterval = 20;
  return await r.loadJSON();
}

async function tryFetchList(pageNumber) {
  const url = `${BASE}/affairs?format=json&lang=en&pageNumber=${pageNumber}`;
  try {
    const data = await fetchJSON(url);
    if (!Array.isArray(data) || data.length === 0) return null;
    return data;
  } catch (e) {
    return null;
  }
}

async function findLastPage() {
  // Exponential search
  let low = 1;
  let high = 1;

  while (true) {
    const data = await tryFetchList(high);
    if (!data) break;

    const last = data[data.length - 1];
    if (last && last.hasMorePages === false) return high;

    low = high;
    high *= 2;

    // sécurité
    if (high > 20000) break;
  }

  // Binary search between (low+1) and (high-1)
  let left = low + 1;
  let right = high - 1;
  let best = low;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const data = await tryFetchList(mid);

    if (!data) {
      right = mid - 1;
      continue;
    }

    const last = data[data.length - 1];
    if (last && last.hasMorePages === false) {
      best = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return best;
}

function normalizeText(s) {
  return String(s || "")
    .replace(/\s+/g, " ")
    .replace(/&nbsp;/g, " ")
    .toLowerCase();
}

function stripHtml(html) {
  return String(html || "").replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim();
}

async function fetchAffair(id, lang) {
  const url = `${BASE}/affairs/${id}?format=json&lang=${encodeURIComponent(lang)}`;
  return await fetchJSON(url);
}

async function fetchCouncillorParty(councillorId, lang) {
  if (!councillorId) return null;
  const url = `${BASE}/councillors/${councillorId}?format=json&lang=${encodeURIComponent(lang)}`;
  try {
    const c = await fetchJSON(url);
    // champs variables selon versions: on tente plusieurs
    return (
      c?.party?.abbreviation ||
      c?.partyAbbreviation ||
      c?.party?.name ||
      null
    );
  } catch (e) {
    return null;
  }
}

function getAuthorNameAndParty(affair) {
  const a = affair?.author || {};
  const c = a?.councillor;

  if (!c) {
    // ex: affaire portée par une commission
    const comm = a?.committee;
    if (comm?.abbreviation1) return { name: comm.abbreviation1, party: null };
    if (comm?.name) return { name: comm.name, party: null };
    return { name: LANG === "fr" ? "—" : "—", party: null };
  }

  const lastName =
    c.officialDenomination ||
    (c.name ? String(c.name).trim().split(/\s+/).slice(-1)[0] : null) ||
    "—";

  // le JSON de l'affaire donne souvent la *fraction* (groupe) et pas le parti
  // => le parti sera complété via /councillors/<id> si possible
  return { name: lastName, party: null, councillorId: c.id };
}

async function getLatestMatchingInterpellations() {
  const lastPage = await findLastPage();

  const results = [];
  const matchedShortIdsForNewCheck = [];

  // On regarde quelques pages en arrière pour trouver 3 matchs
  for (let p = lastPage; p >= Math.max(1, lastPage - 6); p--) {
    const pageList = await tryFetchList(p);
    if (!pageList) continue;

    // derniers d'abord
    for (let i = pageList.length - 1; i >= 0; i--) {
      const item = pageList[i];
      if (!item?.id) continue;

      let affair;
      try {
        affair = await fetchAffair(item.id, LANG);
      } catch (e) {
        continue;
      }

      // type interpellation
      const tId = affair?.affairType?.id;
      if (!TYPE_IDS.has(tId)) continue;

      // contient le mot-clé (dans titre ou textes)
      const haystack =
        normalizeText(affair?.title) +
        " " +
        normalizeText((affair?.texts || []).map(x => x?.value || "").join(" "));
      if (!haystack.includes(normalizeText(KEYWORD))) continue;

      // infos
      const shortId = affair?.shortId || String(item.id);
      const title = affair?.title || "";
      const authorInfo = getAuthorNameAndParty(affair);

      // parti via endpoint councillor (max 3 appels au final)
      let party = null;
      if (authorInfo?.councillorId) {
        party = await fetchCouncillorParty(authorInfo.councillorId, LANG);
      }

      results.push({
        shortId,
        title: stripHtml(title),
        authorLastName: authorInfo.name,
        party: party ? String(party).trim() : null,
      });

      matchedShortIdsForNewCheck.push(shortId);

      if (results.length >= 3) return { results, allMatchedIdsToday: matchedShortIdsForNewCheck, lastPage };
    }
  }

  return { results, allMatchedIdsToday: matchedShortIdsForNewCheck, lastPage };
}

// ------------------ Cache "hier" ------------------
function cachePath(lang) {
  const fm = FileManager.local();
  return fm.joinPath(fm.documentsDirectory(), `cdf_efk_parliament_cache_${lang}.json`);
}

function readCache(lang) {
  const fm = FileManager.local();
  const p = cachePath(lang);
  try {
    if (!fm.fileExists(p)) return [];
    const raw = fm.readString(p);
    const json = JSON.parse(raw);
    return Array.isArray(json) ? json : [];
  } catch (e) {
    return [];
  }
}

function writeCache(lang, arr) {
  const fm = FileManager.local();
  const p = cachePath(lang);
  try {
    fm.writeString(p, JSON.stringify(arr));
  } catch (e) {}
}

function shouldUpdateNow() {
  const now = new Date();
  if (now.getHours() > UPDATE_HOUR) return true;
  if (now.getHours() < UPDATE_HOUR) return false;
  return now.getMinutes() >= UPDATE_MINUTE;
}

// ------------------ Widget UI ------------------
function makeLine(stack, text, font, color) {
  const t = stack.addText(text);
  t.font = font;
  t.textColor = color;
  t.lineLimit = 1;
  return t;
}

function addSpacerH(stack, n) {
  for (let i = 0; i < n; i++) stack.addSpacer(1);
}

async function buildWidget() {
  const w = new ListWidget();
  w.backgroundColor = BG;
  w.url = WIDGET_URL;
  w.setPadding(12, 12, 12, 12);

  // Header
  const header = w.addStack();
  header.layoutHorizontally();
  header.addSpacer();
  const titleTxt = header.addText(TITLE);
  titleTxt.font = Font.boldSystemFont(14);
  titleTxt.textColor = TEXT_PRIMARY;
  header.addSpacer();

  w.addSpacer(8);

  // Data
  const { results, allMatchedIdsToday } = await getLatestMatchingInterpellations();

  // "Nouveaux numéros depuis hier" ligne
  const prev = readCache(LANG);
  const curr = allMatchedIdsToday || [];
  const newOnes = curr.filter(x => !prev.includes(x));

  const newLine = w.addStack();
  newLine.layoutHorizontally();

  const newText =
    newOnes.length > 0 ? newOnes.join("  ") : "❌";
  const newLabel =
    LANG === "fr" ? "Nouveaux: " : "Neu: ";

  const labelTxt = newLine.addText(newLabel);
  labelTxt.font = Font.boldSystemFont(11);
  labelTxt.textColor = TEXT_SECONDARY;

  const valTxt = newLine.addText(newText);
  valTxt.font = Font.systemFont(11);
  valTxt.textColor = newOnes.length > 0 ? RED : TEXT_SECONDARY;
  valTxt.lineLimit = 1;

  w.addSpacer(10);

  // 3 dernières interpellations
  if (!results || results.length === 0) {
    const empty = w.addText(LANG === "fr" ? "Aucune interpellation trouvée." : "Keine Interpellation gefunden.");
    empty.font = Font.systemFont(12);
    empty.textColor = TEXT_SECONDARY;
  } else {
    for (let i = 0; i < results.length; i++) {
      const it = results[i];

      const row = w.addStack();
      row.layoutVertically();

      // Ligne 1: numéro + auteur
      const top = row.addStack();
      top.layoutHorizontally();

      const num = top.addText(it.shortId);
      num.font = Font.boldSystemFont(12);
      num.textColor = TEXT_PRIMARY;

      top.addSpacer(8);

      const who = `${it.authorLastName}${it.party ? " (" + it.party + ")" : ""}`;
      const whoTxt = top.addText(who);
      whoTxt.font = Font.systemFont(11);
      whoTxt.textColor = TEXT_SECONDARY;
      whoTxt.lineLimit = 1;

      // Ligne 2: titre
      const ttl = row.addText(it.title);
      ttl.font = Font.systemFont(11);
      ttl.textColor = TEXT_PRIMARY;
      ttl.lineLimit = 2;

      if (i < results.length - 1) w.addSpacer(8);
    }
  }

  // Mise à jour cache (1x/jour)
  if (shouldUpdateNow()) {
    writeCache(LANG, curr);
  }

  return w;
}

// ------------------ Run ------------------
const widget = await buildWidget();

if (config.runsInWidget) {
  Script.setWidget(widget);
} else {
  // aperçu
  await widget.presentMedium();
}
Script.complete();