// Variables used by Scriptable.
// These must be at the very top of the file. Do not edit.
// icon-color: red; icon-glyph: gavel;

/**
 * Le CDF au Parlement / Die EFK im Parlament
 * Source: Open Data Parlement (ws-old.parlament.ch) en JSON (pas de scraping Curia Vista).
 *
 * Affichage:
 * - Titre centré en haut
 * - Ligne "Nouveaux/Neu": numéros des nouvelles interpellations depuis la dernière mise à jour quotidienne, sinon ❌
 * - 3 dernières interpellations: numéro + titre + Nom (Parti) si possible
 *
 * Tap sur le widget -> ouvre les URLs Curia Vista (FR/DE) EXACTES.
 *
 * Fix design:
 * - Couleurs dynamiques (Light/Dark) pour éviter le widget "tout noir"
 * - Fallback texte visible si aucune donnée
 */

const UPDATE_HOUR = 0;
const UPDATE_MINUTE = 30;

// --- URLs Curia Vista (clic) : EXACTES ---
const CV_FR =
  'https://www.parlament.ch/fr/ratsbetrieb/suche-curia-vista#k=%22Contr%C3%B4le%20f%C3%A9d%C3%A9ral%20des%20finances%22';
const CV_DE =
  'https://www.parlament.ch/de/ratsbetrieb/suche-curia-vista#k=%22Eidgen%C3%B6ssische%20Finanzkontrolle%22#l=1033';

// --- Open Data / API ---
const API_BASE = "https://ws-old.parlament.ch";

// 8 = Interpellation, 9 = Interpellation urgente
const INTERPELLATION_TYPE_IDS = new Set([8, 9]);

const CFG = {
  fr: {
    title: "Le CDF au Parlement",
    keyword: "Contrôle fédéral des finances",
    openUrl: CV_FR,
    apiLang: "fr",
    acceptLang: "fr-CH,fr;q=0.9",
    labelNew: "Nouveaux",
  },
  de: {
    title: "Die EFK im Parlament",
    keyword: "Eidgenössische Finanzkontrolle",
    openUrl: CV_DE,
    apiLang: "de",
    acceptLang: "de-CH,de;q=0.9",
    labelNew: "Neu",
  },
};

// ----------------- Langue auto iOS -----------------
function detectLangAuto() {
  try {
    const pref = Device.preferredLanguages ? Device.preferredLanguages() : [];
    const first = (Array.isArray(pref) && pref.length ? String(pref[0]) : "").toLowerCase();
    if (first.startsWith("fr")) return "fr";
    if (first.startsWith("de")) return "de";
  } catch (_) {}

  const ui = (Device.language() || "").toLowerCase();
  if (ui.startsWith("fr")) return "fr";
  if (ui.startsWith("de")) return "de";
  return "fr";
}

const LANG = detectLangAuto();
const cfg = CFG[LANG];

// ----------------- Couleurs dynamiques (Light/Dark) -----------------
const BG = Color.dynamic(new Color("#FFFFFF"), new Color("#000000"));
const TEXT_PRIMARY = Color.dynamic(new Color("#111111"), new Color("#FFFFFF"));
const TEXT_SECONDARY = Color.dynamic(new Color("#666666"), new Color("#BBBBBB"));
const ACCENT = Color.dynamic(new Color("#E30613"), new Color("#FF6B6B"));

// ----------------- Cache -----------------
const fm = FileManager.local();
const dir = fm.joinPath(fm.documentsDirectory(), "cdf-efk-parliament");
if (!fm.fileExists(dir)) fm.createDirectory(dir, true);

const PATH_CACHE_ITEMS = fm.joinPath(dir, `cache_items_${LANG}.json`);   // [{shortId,title,author,party}]
const PATH_SEEN_IDS = fm.joinPath(dir, `seen_ids_${LANG}.json`);         // [shortId...]
const PATH_LAST_NEW = fm.joinPath(dir, `last_new_${LANG}.json`);         // [shortId...]
const PATH_LAST_UPDATE = fm.joinPath(dir, `last_update_${LANG}.txt`);    // ISO date

function readJSON(path, fallback) {
  try {
    if (!fm.fileExists(path)) return fallback;
    return JSON.parse(fm.readString(path));
  } catch (_) {
    return fallback;
  }
}
function writeJSON(path, obj) {
  try {
    fm.writeString(path, JSON.stringify(obj));
  } catch (_) {}
}
function readText(path, fallback = "") {
  try {
    if (!fm.fileExists(path)) return fallback;
    return fm.readString(path);
  } catch (_) {
    return fallback;
  }
}
function writeText(path, txt) {
  try {
    fm.writeString(path, txt);
  } catch (_) {}
}

function shouldDoDailyUpdate() {
  const now = new Date();
  const last = new Date(readText(PATH_LAST_UPDATE, "1970-01-01T00:00:00.000Z"));
  const todayUpdate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), UPDATE_HOUR, UPDATE_MINUTE);
  return now >= todayUpdate && last < todayUpdate;
}

// ----------------- Helpers texte -----------------
function normalize(s) {
  return String(s || "").replace(/\s+/g, " ").trim();
}
function normalizeLower(s) {
  return normalize(s).toLowerCase();
}
function stripHtml(s) {
  return normalize(String(s || "").replace(/<[^>]*>/g, " "));
}
function clamp(s, max) {
  const t = String(s || "");
  if (t.length <= max) return t;
  return t.slice(0, Math.max(0, max - 1)).trimEnd() + "…";
}
function extractSurname(fullName) {
  const parts = normalize(fullName).split(" ").filter(Boolean);
  return parts.length ? parts[parts.length - 1] : normalize(fullName);
}

// ----------------- API requests -----------------
async function fetchJSON(url) {
  const req = new Request(url);
  req.headers = {
    "Accept": "application/json",
    "Accept-Language": cfg.acceptLang,
    "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15",
  };
  req.timeoutInterval = 25;
  return await req.loadJSON();
}

async function tryFetchAffairsPage(pageNumber) {
  const url = `${API_BASE}/affairs?format=json&lang=en&pageNumber=${pageNumber}`;
  try {
    const data = await fetchJSON(url);
    return Array.isArray(data) ? data : null;
  } catch (_) {
    return null;
  }
}

// Trouver la dernière page (la plus récente)
async function findLastPage() {
  let low = 1;
  let high = 1;

  while (true) {
    const data = await tryFetchAffairsPage(high);
    if (!data || data.length === 0) break;

    const last = data[data.length - 1];
    if (last && last.hasMorePages === false) return high;

    low = high;
    high *= 2;

    if (high > 20000) break;
  }

  let left = low + 1;
  let right = high - 1;
  let best = low;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const data = await tryFetchAffairsPage(mid);

    if (!data || data.length === 0) {
      right = mid - 1;
      continue;
    }

    const last = data[data.length - 1];
    if (last && last.hasMorePages === false) {
      best = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return best;
}

async function fetchAffairById(id) {
  const url = `${API_BASE}/affairs/${id}?format=json&lang=${encodeURIComponent(cfg.apiLang)}`;
  return await fetchJSON(url);
}

async function fetchCouncillorParty(councillorId) {
  if (!councillorId) return null;
  const url = `${API_BASE}/councillors/${councillorId}?format=json&lang=${encodeURIComponent(cfg.apiLang)}`;
  try {
    const c = await fetchJSON(url);
    return c?.party?.abbreviation || c?.partyAbbreviation || c?.party?.name || null;
  } catch (_) {
    return null;
  }
}

function affairContainsKeyword(affair, keyword) {
  const k = normalizeLower(keyword);

  const title = normalizeLower(stripHtml(affair?.title || ""));
  if (title.includes(k)) return true;

  const texts = Array.isArray(affair?.texts) ? affair.texts : [];
  const blob = normalizeLower(texts.map(t => stripHtml(t?.value || "")).join(" "));
  return blob.includes(k);
}

function getShortId(affair, fallbackId) {
  return normalize(affair?.shortId || affair?.shortIdFormatted || fallbackId);
}

function getAuthorSurname(affair) {
  const c = affair?.author?.councillor;
  if (c) {
    const name =
      c.officialDenomination ||
      c.officialDenominationWithTitle ||
      c.name ||
      [c.firstName, c.lastName].filter(Boolean).join(" ") ||
      "";
    return extractSurname(name);
  }

  const comm = affair?.author?.committee;
  if (comm?.abbreviation1) return normalize(comm.abbreviation1);
  if (comm?.name) return normalize(comm.name);

  return "—";
}

async function getLatestMatches(maxMatches = 12, maxPagesBack = 10) {
  const lastPage = await findLastPage();
  const matches = [];

  for (let p = lastPage; p >= Math.max(1, lastPage - maxPagesBack); p--) {
    const pageList = await tryFetchAffairsPage(p);
    if (!pageList || pageList.length === 0) continue;

    for (let i = pageList.length - 1; i >= 0; i--) {
      const item = pageList[i];
      const id = item?.id;
      if (!id) continue;

      let affair;
      try {
        affair = await fetchAffairById(id);
      } catch (_) {
        continue;
      }

      const typeId = affair?.affairType?.id;
      if (!INTERPELLATION_TYPE_IDS.has(typeId)) continue;

      if (!affairContainsKeyword(affair, cfg.keyword)) continue;

      const shortId = getShortId(affair, String(id));
      const title = normalize(stripHtml(affair?.title || ""));
      const authorSurname = getAuthorSurname(affair);

      let party = null;
      const councillorId = affair?.author?.councillor?.id;
      if (councillorId) party = await fetchCouncillorParty(councillorId);

      matches.push({
        shortId,
        title,
        author: authorSurname,
        party: party ? normalize(party) : null,
      });

      if (matches.length >= maxMatches) return matches;
    }
  }

  return matches;
}

// ----------------- UI -----------------
function addCenteredTitle(w, text) {
  const s = w.addStack();
  s.layoutHorizontally();
  s.addSpacer();
  const t = s.addText(text);
  t.font = Font.boldSystemFont(14);
  t.textColor = TEXT_PRIMARY;
  s.addSpacer();
}

function addLabelValueLine(w, label, value, valueColor) {
  const s = w.addStack();
  s.layoutHorizontally();

  const l = s.addText(label);
  l.font = Font.boldSystemFont(11);
  l.textColor = TEXT_SECONDARY;

  const v = s.addText(value);
  v.font = Font.systemFont(11);
  v.textColor = valueColor || TEXT_PRIMARY;
  v.lineLimit = 1;
}

function addItemBlock(w, it) {
  const header = `${it.shortId} — ${clamp(it.title, 70)}`;
  const h = w.addText(header);
  h.font = Font.boldSystemFont(11);
  h.textColor = TEXT_PRIMARY;
  h.lineLimit = 1;

  const who = it.party ? `${it.author} (${it.party})` : it.author;
  const a = w.addText(clamp(who, 40));
  a.font = Font.systemFont(10);
  a.textColor = TEXT_SECONDARY;
  a.lineLimit = 1;
}

// ----------------- Main -----------------
const w = new ListWidget();
w.backgroundColor = BG;
w.url = cfg.openUrl; // clic -> Curia Vista (URL EXACTE)
w.setPadding(6, 12, 12, 12);

addCenteredTitle(w, cfg.title);
w.addSpacer(8);

// Fetch (sinon fallback cache)
let fetched = [];
let fetchOk = false;
try {
  fetched = await getLatestMatches(12, 10);
  fetchOk = Array.isArray(fetched);
} catch (_) {
  fetchOk = false;
}

let items = (fetchOk && fetched.length) ? fetched : readJSON(PATH_CACHE_ITEMS, []);
if (!Array.isArray(items)) items = [];

// Sauver cache si on a des résultats
if (fetchOk && fetched.length) writeJSON(PATH_CACHE_ITEMS, fetched);

// Liste IDs matchés "aujourd’hui"
const matchedIdsToday = items.map(x => x.shortId).filter(Boolean);

// Daily update: calcule "nouveaux" une fois par jour
let newIdsToShow = readJSON(PATH_LAST_NEW, []);
if (!Array.isArray(newIdsToShow)) newIdsToShow = [];

if (shouldDoDailyUpdate()) {
  const seen = readJSON(PATH_SEEN_IDS, []);
  const seenSet = new Set(Array.isArray(seen) ? seen : []);

  const newIds = matchedIdsToday.filter(id => !seenSet.has(id));

  writeJSON(PATH_LAST_NEW, newIds);
  writeJSON(PATH_SEEN_IDS, matchedIdsToday);
  writeText(PATH_LAST_UPDATE, new Date().toISOString());

  newIdsToShow = newIds;
}

// Ligne Nouveaux/Neu
if (newIdsToShow.length) {
  addLabelValueLine(w, `${cfg.labelNew}: `, newIdsToShow.join(" / "), ACCENT);
} else {
  addLabelValueLine(w, `${cfg.labelNew}: `, "❌", TEXT_SECONDARY);
}

w.addSpacer(10);

// 3 dernières
const last3 = items.slice(0, 3);

if (!last3.length) {
  const t = w.addText(fetchOk ? (LANG === "fr" ? "Aucun résultat." : "Keine Resultate.") : (LANG === "fr" ? "Erreur réseau / API." : "Netzwerk-/API-Fehler."));
  t.font = Font.systemFont(12);
  t.textColor = TEXT_SECONDARY;

  const hint = w.addText(LANG === "fr" ? "Ouvre Scriptable > ton script > Run pour voir le log." : "Starte das Script in Scriptable, um das Log zu sehen.");
  hint.font = Font.systemFont(10);
  hint.textColor = TEXT_SECONDARY;
  hint.lineLimit = 2;
} else {
  for (let i = 0; i < last3.length; i++) {
    addItemBlock(w, last3[i]);
    if (i < last3.length - 1) w.addSpacer(8);
  }
}

Script.setWidget(w);
Script.complete();
