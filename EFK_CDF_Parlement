// Variables used by Scriptable.
// These must be at the very top of the file. Do not edit.
// icon-color: red; icon-glyph: gavel;

/**
 * Le CDF au Parlement / Die EFK im Parlament
 * Source: Open Data Parlement (ws-old.parlament.ch) en JSON (pas de scraping Curia Vista).
 *
 * Affichage:
 * - Titre centré en haut
 * - Ligne "Nouveaux/Neu": numéros des nouvelles interpellations depuis la dernière mise à jour quotidienne, sinon ❌
 * - 3 dernières interpellations: numéro + titre + Nom (Parti) si possible
 *
 * Tap sur le widget -> ouvre les URLs Curia Vista (FR/DE) EXACTES.
 *
 * Fix design:
 * - Couleurs dynamiques (Light/Dark) pour éviter le widget "tout noir"
 * - Fallback texte visible si aucune donnée
 */

const UPDATE_HOUR = 0;
const UPDATE_MINUTE = 30;
const CACHE_VALIDITY_HOURS = 6;

// --- URLs Curia Vista (clic) : EXACTES ---
const CV_FR =
  'https://www.parlament.ch/fr/ratsbetrieb/suche-curia-vista#k=%22Contr%C3%B4le%20f%C3%A9d%C3%A9ral%20des%20finances%22';
const CV_DE =
  'https://www.parlament.ch/de/ratsbetrieb/suche-curia-vista#k=%22Eidgen%C3%B6ssische%20Finanzkontrolle%22#l=1033';

// --- Open Data / API ---
const API_BASE = "https://ws-old.parlament.ch";

// 8 = Interpellation, 9 = Interpellation urgente
const INTERPELLATION_TYPE_IDS = new Set([8, 9]);

const CFG = {
  fr: {
    title: "Le CDF au Parlement",
    keyword: "Contrôle fédéral des finances",
    openUrl: CV_FR,
    apiLang: "fr",
    acceptLang: "fr-CH,fr;q=0.9",
    labelNew: "Nouveaux",
  },
  de: {
    title: "Die EFK im Parlament",
    keyword: "Eidgenössische Finanzkontrolle",
    openUrl: CV_DE,
    apiLang: "de",
    acceptLang: "de-CH,de;q=0.9",
    labelNew: "Neu",
  },
};

// ----------------- Langue auto iOS -----------------
function detectLangAuto() {
  try {
    const pref = Device.preferredLanguages ? Device.preferredLanguages() : [];
    const first = (Array.isArray(pref) && pref.length ? String(pref[0]) : "").toLowerCase();
    if (first.startsWith("fr")) return "fr";
    if (first.startsWith("de")) return "de";
  } catch (_) {}

  const ui = (Device.language() || "").toLowerCase();
  if (ui.startsWith("fr")) return "fr";
  if (ui.startsWith("de")) return "de";
  return "fr";
}

const LANG = detectLangAuto();
const cfg = CFG[LANG];

// ----------------- Couleurs dynamiques (Light/Dark) -----------------
const BG = Color.dynamic(new Color("#FFFFFF"), new Color("#1C1C1E"));
const TEXT_PRIMARY = Color.dynamic(new Color("#000000"), new Color("#FFFFFF"));
const TEXT_SECONDARY = Color.dynamic(new Color("#666666"), new Color("#AAAAAA"));
const ACCENT = Color.dynamic(new Color("#E30613"), new Color("#FF6B6B"));

// ----------------- Cache -----------------
const fm = FileManager.local();
const dir = fm.joinPath(fm.documentsDirectory(), "cdf-efk-parliament");
if (!fm.fileExists(dir)) fm.createDirectory(dir, true);

const PATH_CACHE_ITEMS = fm.joinPath(dir, `cache_items_${LANG}.json`);   // [{shortId,title,author,party}]
const PATH_SEEN_IDS = fm.joinPath(dir, `seen_ids_${LANG}.json`);         // [shortId...]
const PATH_LAST_NEW = fm.joinPath(dir, `last_new_${LANG}.json`);         // [shortId...]
const PATH_LAST_UPDATE = fm.joinPath(dir, `last_update_${LANG}.txt`);    // ISO date
const PATH_LAST_FETCH = fm.joinPath(dir, `last_fetch_${LANG}.txt`);      // ISO date du dernier fetch
const PATH_LAST_AFFAIR_ID = fm.joinPath(dir, `last_affair_id_${LANG}.txt`); // Dernier ID d'affair vérifié

function readJSON(path, fallback) {
  try {
    if (!fm.fileExists(path)) return fallback;
    return JSON.parse(fm.readString(path));
  } catch (_) {
    return fallback;
  }
}
function writeJSON(path, obj) {
  try {
    fm.writeString(path, JSON.stringify(obj));
  } catch (_) {}
}
function readText(path, fallback = "") {
  try {
    if (!fm.fileExists(path)) return fallback;
    return fm.readString(path);
  } catch (_) {
    return fallback;
  }
}
function writeText(path, txt) {
  try {
    fm.writeString(path, txt);
  } catch (_) {}
}

function shouldDoDailyUpdate() {
  const now = new Date();
  const last = new Date(readText(PATH_LAST_UPDATE, "1970-01-01T00:00:00.000Z"));
  const todayUpdate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), UPDATE_HOUR, UPDATE_MINUTE);
  return now >= todayUpdate && last < todayUpdate;
}

function isCacheValid() {
  const now = new Date();
  const lastFetch = new Date(readText(PATH_LAST_FETCH, "1970-01-01T00:00:00.000Z"));
  const hoursSinceLastFetch = (now - lastFetch) / (1000 * 60 * 60);
  return hoursSinceLastFetch < CACHE_VALIDITY_HOURS;
}

// ----------------- Helpers texte -----------------
function normalize(s) {
  return String(s || "").replace(/\s+/g, " ").trim();
}
function normalizeLower(s) {
  return normalize(s).toLowerCase();
}
function stripHtml(s) {
  return normalize(String(s || "").replace(/<[^>]*>/g, " "));
}
function clamp(s, max) {
  const t = String(s || "");
  if (t.length <= max) return t;
  return t.slice(0, Math.max(0, max - 1)).trimEnd() + "…";
}
function extractSurname(fullName) {
  const parts = normalize(fullName).split(" ").filter(Boolean);
  return parts.length ? parts[parts.length - 1] : normalize(fullName);
}

// ----------------- API requests -----------------
async function fetchJSON(url) {
  const req = new Request(url);
  req.headers = {
    "Accept": "application/json",
    "Accept-Language": cfg.acceptLang,
    "User-Agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15",
  };
  req.timeoutInterval = 10;
  
  try {
    const response = await req.loadString();
    if (!response || response.trim().length === 0) {
      throw new Error("Réponse vide");
    }
    return JSON.parse(response);
  } catch (e) {
    console.error(`[ERROR] fetchJSON failed for ${url}: ${e}`);
    throw e;
  }
}

// Rechercher les interpellations contenant le mot-clé CDF/EFK
async function searchAffairsByKeyword() {
  // Utiliser l'endpoint de recherche avec le mot-clé
  const searchUrl = `${API_BASE}/affairs?format=json&lang=${cfg.apiLang}&searchText=${encodeURIComponent(cfg.keyword)}`;
  console.log(`[DEBUG] Recherche: ${searchUrl}`);
  
  try {
    const data = await fetchJSON(searchUrl);
    if (Array.isArray(data) && data.length > 0) {
      console.log(`[DEBUG] ${data.length} résultats trouvés pour "${cfg.keyword}"`);
      return data;
    }
    console.warn(`[WARN] Aucun résultat pour "${cfg.keyword}"`);
    return [];
  } catch (e) {
    console.error(`[ERROR] Échec recherche: ${e}`);
    return [];
  }
}

async function fetchAffairById(id) {
  const url = `${API_BASE}/affairs/${id}?format=json&lang=${encodeURIComponent(cfg.apiLang)}`;
  try {
    return await fetchJSON(url);
  } catch (e) {
    console.error(`[ERROR] Échec fetch affair ${id}: ${e}`);
    throw e;
  }
}

async function fetchCouncillorParty(councillorId) {
  if (!councillorId) return null;
  const url = `${API_BASE}/councillors/${councillorId}?format=json&lang=${encodeURIComponent(cfg.apiLang)}`;
  try {
    const c = await fetchJSON(url);
    return c?.party?.abbreviation || c?.partyAbbreviation || c?.party?.name || null;
  } catch (_) {
    return null;
  }
}

function affairContainsKeyword(affair, keyword) {
  const k = normalizeLower(keyword);

  const title = normalizeLower(stripHtml(affair?.title || ""));
  if (title.includes(k)) return true;

  const texts = Array.isArray(affair?.texts) ? affair.texts : [];
  const blob = normalizeLower(texts.map(t => stripHtml(t?.value || "")).join(" "));
  return blob.includes(k);
}

function getShortId(affair, fallbackId) {
  return normalize(affair?.shortId || affair?.shortIdFormatted || fallbackId);
}

function getAuthorSurname(affair) {
  const c = affair?.author?.councillor;
  if (c) {
    const name =
      c.officialDenomination ||
      c.officialDenominationWithTitle ||
      c.name ||
      [c.firstName, c.lastName].filter(Boolean).join(" ") ||
      "";
    return extractSurname(name);
  }

  const comm = affair?.author?.committee;
  if (comm?.abbreviation1) return normalize(comm.abbreviation1);
  if (comm?.name) return normalize(comm.name);

  return "—";
}

async function getNewMatches() {
  console.log("[DEBUG] Recherche des interpellations CDF/EFK...");
  
  // Rechercher directement par mot-clé
  const searchResults = await searchAffairsByKeyword();
  if (!searchResults || searchResults.length === 0) {
    console.warn("[WARN] Aucun résultat de recherche");
    return [];
  }
  
  const matches = [];
  const lastSeenId = parseInt(readText(PATH_LAST_AFFAIR_ID, "0"));
  let newLastId = lastSeenId;
  
  console.log(`[DEBUG] Traitement de ${searchResults.length} résultats...`);
  
  // Traiter les résultats (limité aux 20 premiers pour éviter timeout)
  for (let i = 0; i < Math.min(searchResults.length, 20); i++) {
    const item = searchResults[i];
    const id = item?.id;
    if (!id) continue;
    
    // Mettre à jour le dernier ID vu
    if (id > newLastId) newLastId = id;
    
    let affair;
    try {
      affair = await fetchAffairById(id);
    } catch (e) {
      console.warn(`[WARN] Skip affair ${id}: ${e}`);
      continue;
    }
    
    const typeId = affair?.affairType?.id;
    const shortId = getShortId(affair, String(id));
    
    // Filtrer uniquement les interpellations (type 8 et 9)
    if (!INTERPELLATION_TYPE_IDS.has(typeId)) {
      console.log(`[DEBUG] ${shortId}: Type ${typeId} ignoré`);
      continue;
    }
    
    const title = normalize(stripHtml(affair?.title || ""));
    const authorSurname = getAuthorSurname(affair);
    
    let party = null;
    const councillorId = affair?.author?.councillor?.id;
    if (councillorId) {
      try {
        party = await fetchCouncillorParty(councillorId);
      } catch (e) {
        // Ignorer l'erreur, continuer sans le parti
      }
    }
    
    matches.push({
      shortId,
      title,
      author: authorSurname,
      party: party ? normalize(party) : null,
    });
    console.log(`[DEBUG] Interpellation trouvée: ${shortId}`);
    
    if (matches.length >= 10) {
      console.log(`[DEBUG] 10 interpellations trouvées, arrêt`);
      break;
    }
  }
  
  // Sauvegarder le dernier ID vérifié
  if (newLastId > lastSeenId) {
    writeText(PATH_LAST_AFFAIR_ID, String(newLastId));
  }
  
  console.log(`[DEBUG] Total interpellations: ${matches.length}`);
  return matches;
}

// ----------------- UI -----------------
function addCenteredTitle(w, text) {
  const s = w.addStack();
  s.layoutHorizontally();
  s.addSpacer();
  const t = s.addText(text);
  t.font = Font.boldSystemFont(14);
  t.textColor = TEXT_PRIMARY;
  s.addSpacer();
}

function addLabelValueLine(w, label, value, valueColor) {
  const s = w.addStack();
  s.layoutHorizontally();

  const l = s.addText(label);
  l.font = Font.boldSystemFont(11);
  l.textColor = TEXT_SECONDARY;

  const v = s.addText(value);
  v.font = Font.systemFont(11);
  v.textColor = valueColor || TEXT_PRIMARY;
  v.lineLimit = 1;
}

function addItemBlock(w, it) {
  const header = `${it.shortId} — ${clamp(it.title, 70)}`;
  const h = w.addText(header);
  h.font = Font.boldSystemFont(11);
  h.textColor = TEXT_PRIMARY;
  h.lineLimit = 1;

  const who = it.party ? `${it.author} (${it.party})` : it.author;
  const a = w.addText(clamp(who, 40));
  a.font = Font.systemFont(10);
  a.textColor = TEXT_SECONDARY;
  a.lineLimit = 1;
}

// ----------------- Main -----------------
const w = new ListWidget();
w.backgroundColor = BG;
w.url = cfg.openUrl; // clic -> Curia Vista (URL EXACTE)
w.setPadding(6, 12, 12, 12);

addCenteredTitle(w, cfg.title);
w.addSpacer(8);

// Fetch (sinon fallback cache)
let fetched = [];
let fetchOk = false;
let errorMsg = "";
let usedCache = false;
let items = [];

// Vérifier si le cache est valide ET non vide
const cachedItems = readJSON(PATH_CACHE_ITEMS, []);
const cacheHasData = Array.isArray(cachedItems) && cachedItems.length > 0;

if (isCacheValid() && cacheHasData) {
  console.log(`[DEBUG] Cache valide avec ${cachedItems.length} items, utilisation du cache`);
  items = cachedItems;
  usedCache = true;
  fetchOk = true;
} else {
  console.log(`[DEBUG] Cache ${cacheHasData ? "expiré" : "vide"}, fetch API...`);
  
  // Si le cache est vide, réinitialiser le lastSeenId pour forcer une recherche complète
  if (!cacheHasData) {
    console.log("[DEBUG] Réinitialisation du lastSeenId pour recherche complète");
    writeText(PATH_LAST_AFFAIR_ID, "0");
  }
  
  try {
    fetched = await getNewMatches();
    fetchOk = Array.isArray(fetched);
    console.log(`[DEBUG] Fetch OK: ${fetchOk}, Interpellations trouvées: ${fetched.length}`);
  } catch (e) {
    fetchOk = false;
    errorMsg = String(e);
    console.error(`[ERROR] Fetch échoué: ${errorMsg}`);
  }
  
  // Fusionner les nouvelles avec le cache (nouvelles en premier)
  if (fetchOk && fetched.length > 0) {
    items = [...fetched, ...cachedItems];
    // Garder seulement les 20 plus récentes
    items = items.slice(0, 20);
    writeJSON(PATH_CACHE_ITEMS, items);
    writeText(PATH_LAST_FETCH, new Date().toISOString());
    console.log(`[DEBUG] Cache mis à jour avec ${fetched.length} nouvelles interpellations`);
  } else {
    items = cachedItems;
  }
  
  if (!Array.isArray(items)) items = [];
  console.log(`[DEBUG] Items à afficher: ${items.length}`);
}

// Liste IDs matchés "aujourd’hui"
const matchedIdsToday = items.map(x => x.shortId).filter(Boolean);

// Daily update: calcule "nouveaux" une fois par jour
let newIdsToShow = readJSON(PATH_LAST_NEW, []);
if (!Array.isArray(newIdsToShow)) newIdsToShow = [];

if (shouldDoDailyUpdate()) {
  const seen = readJSON(PATH_SEEN_IDS, []);
  const seenSet = new Set(Array.isArray(seen) ? seen : []);

  const newIds = matchedIdsToday.filter(id => !seenSet.has(id));

  writeJSON(PATH_LAST_NEW, newIds);
  writeJSON(PATH_SEEN_IDS, matchedIdsToday);
  writeText(PATH_LAST_UPDATE, new Date().toISOString());

  newIdsToShow = newIds;
}

// Ligne Nouveaux/Neu
if (newIdsToShow.length) {
  addLabelValueLine(w, `${cfg.labelNew}: `, newIdsToShow.join(" / "), ACCENT);
} else {
  addLabelValueLine(w, `${cfg.labelNew}: `, "❌", TEXT_SECONDARY);
}

w.addSpacer(10);

// 3 dernières
const last3 = items.slice(0, 3);

if (!last3.length) {
  console.warn("[WARN] Aucun résultat à afficher!");
  const msg = fetchOk ? (LANG === "fr" ? "Aucun résultat trouvé." : "Keine Resultate.") : (LANG === "fr" ? "Erreur réseau / API" : "Netzwerk-/API-Fehler");
  const t = w.addText(msg);
  t.font = Font.boldSystemFont(13);
  t.textColor = ACCENT;

  w.addSpacer(6);
  
  const hint = w.addText(LANG === "fr" ? "Ouvre Scriptable et lance le script pour voir les logs de debug." : "Öffne Scriptable und starte das Script für Debug-Logs.");
  hint.font = Font.systemFont(11);
  hint.textColor = TEXT_PRIMARY;
  hint.lineLimit = 3;
  
  if (errorMsg) {
    w.addSpacer(6);
    const err = w.addText(`Erreur: ${clamp(errorMsg, 80)}`);
    err.font = Font.systemFont(9);
    err.textColor = TEXT_SECONDARY;
    err.lineLimit = 2;
  }
} else {
  for (let i = 0; i < last3.length; i++) {
    addItemBlock(w, last3[i]);
    if (i < last3.length - 1) w.addSpacer(8);
  }
}

Script.setWidget(w);
Script.complete();
